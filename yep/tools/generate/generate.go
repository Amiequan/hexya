// Copyright 2016 NDP Syst√®mes. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generate

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/types"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/inconshreveable/log15"
	"github.com/npiganeau/yep/yep/tools/logging"
	"golang.org/x/tools/go/loader"
)

const (
	// YEPPath is the go import path of the base yep package
	YEPPath string = "github.com/npiganeau/yep"
	// ConfigPath is the go import path of the yep/config package
	ConfigPath string = "github.com/npiganeau/yep/config"
	// ModelsPath is the go import path of the yep/models package
	ModelsPath string = "github.com/npiganeau/yep/yep/models"
	// TypesPath is the go import path of the yep/models/types package
	TypesPath string = "github.com/npiganeau/yep/yep/models/types"
	// GeneratePath is the go import path of this package
	GeneratePath string = "github.com/npiganeau/yep/yep/tools/generate"
	// PoolPath is the go import path of the autogenerated pool package
	PoolPath string = "github.com/npiganeau/yep/pool"
	// TestModulePath is the go import path of the yep/tests package
	TestModulePath string = "github.com/npiganeau/yep/yep/tests/test_module"
)

var (
	log log15.Logger
	// YEPDir is the directory of the base yep package
	YEPDir string
)

// CreateFileFromTemplate generates a new file from the given template and data
func CreateFileFromTemplate(fileName string, template *template.Template, data interface{}) {
	var srcBuffer bytes.Buffer
	template.Execute(&srcBuffer, data)
	srcData, err := format.Source(srcBuffer.Bytes())
	if err != nil {
		logging.LogAndPanic(log, "Error while formatting generated source file", "error", err, "fileName",
			fileName, "mData", fmt.Sprintf("%#v", data), "src", srcBuffer.String())
	}
	// Write to file
	err = ioutil.WriteFile(fileName, srcData, 0644)
	if err != nil {
		logging.LogAndPanic(log, "Error while saving generated source file", "error", err, "fileName", fileName)
	}
}

// A PackageType describes a type of module
type PackageType int8

const (
	// Base is the PackageType for the base package of a module
	Base PackageType = iota
	// Defs is the PackageType for the defs package of a module
	Defs
	// Subs is the PackageType for a sub package of a module (that is not defs)
	Subs
	// Models is the PackageType for the yep/models package
	Models
)

// A ModuleInfo is a wrapper around loader.Package with additional data to
// describe a module.
type ModuleInfo struct {
	loader.PackageInfo
	ModType PackageType
}

// NewModuleInfo returns a pointer to a new moduleInfo instance
func NewModuleInfo(pack *loader.PackageInfo, modType PackageType) *ModuleInfo {
	return &ModuleInfo{
		PackageInfo: *pack,
		ModType:     modType,
	}
}

// GetModulePackages returns a slice of PackageInfo for packages that are yep modules, that is:
// - A package that declares a "MODULE_NAME" constant
// - A package that is in a subdirectory of a package
// Also returns the 'yep/models' package since all models are initialized there
func GetModulePackages(program *loader.Program) []*ModuleInfo {
	modules := make(map[string]*ModuleInfo)

	// We add to the modulePaths all packages which define a MODULE_NAME constant
	// and we check for 'yep/models' package
	for _, pack := range program.AllPackages {
		obj := pack.Pkg.Scope().Lookup("MODULE_NAME")
		_, ok := obj.(*types.Const)
		if ok {
			modules[pack.Pkg.Path()] = NewModuleInfo(pack, Base)
			continue
		}
		if pack.Pkg.Path() == ModelsPath {
			modules[pack.Pkg.Path()] = NewModuleInfo(pack, Models)
		}
	}

	// Now we add packages that live inside another module
	for _, pack := range program.AllPackages {
		for _, module := range modules {
			if strings.HasPrefix(pack.Pkg.Path(), module.Pkg.Path()) {
				typ := Subs
				if strings.HasSuffix(pack.String(), "defs") {
					typ = Defs
				}
				modules[pack.Pkg.Path()] = NewModuleInfo(pack, typ)
			}
		}
	}

	// Finally, we build up our result slice from modules map
	modSlice := make([]*ModuleInfo, len(modules))
	var i int
	for _, mod := range modules {
		modSlice[i] = mod
		i++
	}
	return modSlice
}

// A MethodRef is a map key for a method in a model
type MethodRef struct {
	Model  string
	Method string
}

// A TypeData holds a Type string and optional import path for this type.
type TypeData struct {
	Types       []string
	ImportPaths []string
}

// A MethodASTData is a holder for a function's doc string and parameters names
type MethodASTData struct {
	Params     []string
	ReturnType TypeData
}

// GetMethodsASTData returns the parameters names of all methods of the given path.
// paths must be a slice of go import path string.
func GetMethodsASTData(paths []string) map[MethodRef]MethodASTData {
	// Parse source code
	conf := loader.Config{
		AllowErrors: true,
		ParserMode:  parser.ParseComments,
	}
	for _, path := range paths {
		conf.Import(path)
	}
	program, err := conf.Load()
	if err != nil {
		logging.LogAndPanic(log, "Unable to load program", "error", err, "paths", paths)
	}
	modInfos := GetModulePackages(program)
	return GetMethodsASTDataForModules(modInfos)
}

// GetMethodsASTDataForModules returns the MethodASTData for all methods in given modules.
func GetMethodsASTDataForModules(modInfos []*ModuleInfo) map[MethodRef]MethodASTData {
	res := make(map[MethodRef]MethodASTData)
	// Parse all modules for comments and params names
	// In the same loop, we both :
	// - Get method ast data for all functions
	// - Get the list of methods by parsing 'CreateMethod'
	meths := make(map[MethodRef]ast.Node)
	funcs := make(map[ast.Node]MethodASTData)
	for _, modInfo := range modInfos {
		for _, file := range modInfo.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				switch node := n.(type) {
				case *ast.CallExpr:
					fNode, ok := node.Fun.(*ast.SelectorExpr)
					if !ok {
						return true
					}
					if fNode.Sel.Name != "CreateMethod" {
						return true
					}

					modelName, err := extractModel(fNode.X)
					if err != nil {
						logging.LogAndPanic(log, "Unable to extract model while visiting AST", "error", err)
					}
					methodName := ""
					if mn, ok := node.Args[0].(*ast.BasicLit); ok {
						methodName = strings.Trim(mn.Value, `"`)
					}

					var funcType *ast.FuncType
					switch fd := node.Args[2].(type) {
					case *ast.Ident:
						funcType = fd.Obj.Decl.(*ast.FuncDecl).Type
					case *ast.FuncLit:
						funcType = fd.Type
					}
					res[MethodRef{Model: modelName, Method: methodName}] = MethodASTData{
						Params:     extractParams(funcType),
						ReturnType: extractReturnType(funcType, modInfo),
					}
				}
				return true
			})
		}
	}
	// Now we extract params from funcs only for methods
	for ref, meth := range meths {
		res[ref] = funcs[meth]
	}
	return res
}

// extractModel returns the string name of the model of the given ident variable
// Returns an error if it cannot determine the model
func extractModel(ident ast.Expr) (string, error) {
	switch idt := ident.(type) {
	case *ast.Ident:
		// CreateMethod is called on an identifier without selector such as
		// user.createMethod. In this case, we try to find out the model from
		// the identifier declaration.
		switch decl := idt.Obj.Decl.(type) {
		case *ast.AssignStmt:
			// The declaration is also an assignment
			switch rd := decl.Rhs[0].(type) {
			case *ast.CallExpr:
				// The assignment is a call to a function
				var fnIdent *ast.Ident
				switch ft := rd.Fun.(type) {
				case *ast.Ident:
					fnIdent = ft
				case *ast.SelectorExpr:
					fnIdent = ft.Sel
				}
				switch fnIdent.Name {
				case "MustGet", "NewModel", "NewMixinModel", "NewTransientModel":
					return strings.Trim(rd.Args[0].(*ast.BasicLit).Value, `"`), nil
				default:
					return extractModelNameFromFunc(rd)
				}
			case *ast.Ident:
				// The assignment is another identifier, we go to the declaration of this new ident.
				return extractModel(rd)
			default:
				return "", fmt.Errorf("Unmanaged type %T for %s", rd, idt.Name)
			}
		}
	case *ast.CallExpr:
		// CreateMethod is called on a function call.
		// We are interested only if it is from the pool package (e.g. pool.User())
		return extractModelNameFromFunc(idt)
	}
	return "", errors.New("Unmanaged situation")
}

// extractModelNameFromFunc extracts the model name from a pool.ModelName()
// expression or an error if this is not a pool function.
func extractModelNameFromFunc(ce *ast.CallExpr) (string, error) {
	switch ft := ce.Fun.(type) {
	case *ast.Ident:
		// func is called without selector, then it is not from pool
		return "", errors.New("Function call without selector")
	case *ast.SelectorExpr:
		if pkg, ok := ft.X.(*ast.Ident); !ok || pkg.Name != "pool" {
			return "", errors.New("Selector not from pool package")
		}
		return ft.Sel.Name, nil
	}
	return "", errors.New("Unparsable function call")
}

// extractParams extracts the parameters name of the given FuncType
func extractParams(ft *ast.FuncType) []string {
	var params []string
	for i, pl := range ft.Params.List {
		if i == 0 {
			// pass the first argument (rs)
			continue
		}
		for _, nn := range pl.Names {
			params = append(params, nn.Name)
		}
	}
	return params
}

// extractReturnType returns the return type of the first returned value
// of the given FuncType as a string and an import path if needed.
func extractReturnType(ft *ast.FuncType, modInfo *ModuleInfo) TypeData {
	sanitize := func(rt, ip string) (string, string) {
		if strings.Contains(ip, PoolPath) {
			rt = strings.Replace(rt, "pool.", "", 1)
			ip = ""
		}

		importPathTokens := strings.Split(ip, ".")
		if len(importPathTokens) > 0 {
			ip = strings.Join(importPathTokens[:len(importPathTokens)-1], ".")
		}
		return rt, ip
	}
	var returnTypes, importPaths []string
	if ft.Results != nil {
		for _, l := range ft.Results.List {
			rt, ip := sanitize(types.TypeString(modInfo.TypeOf(l.Type), (*types.Package).Name), computeExportPath(modInfo.TypeOf(l.Type)))
			returnTypes = append(returnTypes, rt)
			importPaths = append(importPaths, ip)
		}
	}
	return TypeData{
		Types:       returnTypes,
		ImportPaths: importPaths,
	}
}

// computeExportPath returns the import path of the given type
func computeExportPath(typ types.Type) string {
	var res string
	switch typ := typ.(type) {
	case *types.Struct, *types.Named:
		res = types.TypeString(typ, (*types.Package).Path)
	case *types.Pointer:
		res = computeExportPath(typ.Elem())
	case *types.Slice:
		res = computeExportPath(typ.Elem())
	}
	return res
}

func init() {
	log = logging.GetLogger("tools/generate")
	yepPack, err := build.Import(YEPPath, ".", build.FindOnly)
	if err != nil {
		panic(fmt.Errorf("Error while getting YEP root path: %s", err))
	}
	YEPDir = yepPack.Dir
}
